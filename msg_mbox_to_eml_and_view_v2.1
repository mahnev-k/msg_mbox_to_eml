import sys
import os
import mimetypes
import extract_msg
import mailbox
import email
import subprocess
import logging
import re
import hashlib
import time
import base64
import codecs
import json
from pathlib import Path
from datetime import datetime
from email.utils import formatdate, parsedate_tz, mktime_tz
from email.header import decode_header, Header
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email import encoders
from email.message import EmailMessage
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel, QPushButton, QFileDialog,
    QListWidget, QMessageBox, QProgressBar, QHBoxLayout, QToolButton, QMenu,
    QAction, QDialog, QTextEdit, QListWidgetItem, QRadioButton,
    QAbstractItemView
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5.QtGui import QIcon

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

CONFIG_FILE = os.path.join(os.path.expanduser("~"), ".msg_to_eml_config.json")

class MessageConverter:
    def generate_safe_filename(self, original_path, new_extension):
        base_name = os.path.splitext(os.path.basename(original_path))[0]
        safe_name = sanitize_filename(base_name)
        
        if not safe_name:
            safe_name = "converted_message"
        
        return safe_name + new_extension

    def parse_msg_date(self, date_obj):
        """Парсинг даты из MSG объекта"""
        if date_obj is None:
            return datetime.now()
            
        if isinstance(date_obj, datetime):
            return date_obj
            
        if isinstance(date_obj, str):
            try:
                for fmt in ['%a, %d %b %Y %H:%M:%S %z', '%d %b %Y %H:%M:%S', '%Y-%m-%d %H:%M:%S']:
                    try:
                        return datetime.strptime(date_obj, fmt)
                    except ValueError:
                        continue
            except:
                pass
        
        return datetime.now()

    def process_html_with_inline_images(self, html, inline_attachments, cid_mapping):

        if not html or not inline_attachments:
            return html

        if isinstance(html, bytes):
            html = html.decode('utf-8', errors='replace')

        def repl(match):
            src = match.group(1)
            if src.lower().startswith("cid:"):
                cid = src[4:].strip('<>')
                
                for att in inline_attachments:
                    att_cid = getattr(att, 'cid', None) or getattr(att, 'contentId', None)
                    if att_cid and att_cid.strip('<>') == cid:
                        filename = (getattr(att, 'longFilename', None) or 
                                getattr(att, 'shortFilename', None) or 
                                f"image_{hashlib.md5(cid.encode()).hexdigest()[:8]}")
                        
                        cid_mapping[filename] = cid
                        
                        return f'src="cid:{cid}"'
            
            return match.group(0)

        return re.sub(r'src=["\']cid:([^"\']+)["\']', repl, html, flags=re.IGNORECASE)

    def is_inline_attachment(self, attachment):

        try:
            cid = getattr(attachment, 'cid', None) or getattr(attachment, 'contentId', None)
            if cid:
                return True
                
            content_disposition = getattr(attachment, 'contentDisposition', '') or ''
            if 'inline' in content_disposition.lower():
                return True
                
            filename = (getattr(attachment, 'longFilename', None) or 
                    getattr(attachment, 'shortFilename', None) or '')
            if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                return True
                
            mime_type = getattr(attachment, 'mimeType', None)
            if mime_type and mime_type.startswith('image/'):
                return True
                
        except Exception:
            pass
            
        return False

    def decode_text(self, text):
      if text is None:
            return ""
        
      if isinstance(text, bytes):
            try:
                for encoding in ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1', 'cp866']:
                    try:
                        return text.decode(encoding)
                    except UnicodeDecodeError:
                        continue
                return text.decode('utf-8', errors='replace')
            except Exception:
                return str(text)
      else:
           return str(text)

    def get_safe_recipients(self, recipients):

        if not recipients:
            return ""
        
        recipient_list = []
        for recipient in recipients:
            if hasattr(recipient, 'email') and recipient.email:
                recipient_list.append(recipient.email)
            elif hasattr(recipient, 'display_name') and recipient.display_name:
                recipient_list.append(recipient.display_name)
            elif isinstance(recipient, str):
                recipient_list.append(recipient)
            else:
                try:
                    recipient_list.append(str(recipient))
                except:
                    recipient_list.append("Unknown")
        
        return ", ".join(recipient_list)

    def __init__(self, output_dir):
        self.output_dir = output_dir

    def encode_header(self, text):
        if not text:
            return ""
        try:
            if isinstance(text, bytes):
                text = text.decode('utf-8', errors='replace')
            if any(ord(c) > 127 for c in text):
                from email.header import Header
                return str(Header(text, 'utf-8'))
            return text
        except Exception as e:
            logger.error(f"Ошибка кодирования заголовка: {e}")
            return str(text)

    def convert_msg_to_eml(self, msg_path):
        try:
            msg = extract_msg.Message(msg_path)
            
            msg_sender = getattr(msg, 'sender', None) or ""
            recipients = getattr(msg, 'recipients', None)
            if recipients is None:
              recipients = getattr(msg, 'to', None) or getattr(msg, 'display_to', None)
            msg_to = self.get_safe_recipients(recipients) if recipients else ""
            msg_subject = getattr(msg, 'subject', None) or ""
            msg_body = self.decode_text(getattr(msg, 'body', None))
            msg_html = self.decode_text(getattr(msg, 'htmlBody', None))

            attachments = getattr(msg, 'attachments', [])
            inline_attachments = []
            regular_attachments = []
            cid_mapping = {} 

            for att in attachments:
                if self.is_inline_attachment(att):
                    inline_attachments.append(att)
                else:
                    regular_attachments.append(att)

            if msg_html and inline_attachments:
                msg_html = self.process_html_with_inline_images(msg_html, inline_attachments, cid_mapping)

            if not msg_body and not msg_html:
                outer = email.mime.text.MIMEText("", "plain", "utf-8")
            elif msg_html and not msg_body:
                if inline_attachments:
                    outer = MIMEMultipart("related")
                    html_part = MIMEText(msg_html, "html", "utf-8")
                    outer.attach(html_part)
                    
                    for att in inline_attachments:
                        self.process_inline_attachment(att, outer, cid_mapping)
                else:
                    outer = MIMEText(msg_html, "html", "utf-8")
            elif msg_body and not msg_html:
                outer = MIMEText(msg_body, "plain", "utf-8")
            else:
                if inline_attachments:
                    outer = MIMEMultipart("alternative")
                    
                    text_part = MIMEText(msg_body, "plain", "utf-8")
                    outer.attach(text_part)
                    
                    html_related = MIMEMultipart("related")
                    html_part = MIMEText(msg_html, "html", "utf-8")
                    html_related.attach(html_part)
                    
                    for att in inline_attachments:
                        self.process_inline_attachment(att, html_related, cid_mapping)
                    
                    outer.attach(html_related)
                else:
                    outer = MIMEMultipart("alternative")
                    outer.attach(MIMEText(msg_body, "plain", "utf-8"))
                    outer.attach(MIMEText(msg_html, "html", "utf-8"))

            if regular_attachments:
                if isinstance(outer, MIMEMultipart):
                    mixed_outer = MIMEMultipart("mixed")
                    for key, value in outer.items():
                        mixed_outer[key] = value
                    mixed_outer.attach(outer)
                else:
                    mixed_outer = MIMEMultipart("mixed")
                    for key, value in outer.items():
                        mixed_outer[key] = value
                    mixed_outer.attach(outer)
                
                outer = mixed_outer

                for att in regular_attachments:
                    try:
                        self.process_regular_attachment(att, outer)
                    except Exception as e:
                        logger.warning(f"Ошибка при обработке вложения: {str(e)}")
                        continue

            outer["Subject"] = msg_subject
            outer["From"] = msg_sender
            outer["To"] = msg_to
            outer["Message-ID"] = f"<{hash(msg_path)}@converted.local>"
            
            msg_date = None
            if hasattr(msg, 'date') and msg.date:
                msg_date = self.parse_msg_date(msg.date)
            else:
                for attr in ['creationTime', 'lastModificationTime', 'receivedTime']:
                    if hasattr(msg, attr):
                        attr_value = getattr(msg, attr)
                        if attr_value:
                            msg_date = self.parse_msg_date(attr_value)
                            break

            if not msg_date:
                msg_date = datetime.now()

            try:
                formatted_date = formatdate(msg_date.timestamp(), localtime=True)
            except:
                formatted_date = formatdate(time.time(), localtime=True)

            outer["Date"] = formatted_date

            outer["MIME-Version"] = "1.0"

            out_filename = self.generate_safe_filename(msg_path, ".eml")
            out_path = os.path.join(self.output_dir, out_filename)
            
            with open(out_path, "w", encoding="utf-8", newline='\n') as f:
                f.write(outer.as_string())

            logger.info(f"Успешно конвертирован: {msg_path} -> {out_path}")
            return out_path

        except Exception as e:
            logger.error(f"Ошибка конвертации MSG файла {msg_path}: {str(e)}")
            raise

    def process_inline_attachment(self, att, parent, cid_mapping):
        filename = (getattr(att, 'longFilename', None) or 
                   getattr(att, 'shortFilename', None) or 
                   "inline_image")
        
        data = getattr(att, 'data', None)
        if data is None:
            return
            
        if isinstance(data, str):
            data = data.encode(errors="replace")
        elif not isinstance(data, bytes):
            data = bytes(data)

        mime_type, _ = mimetypes.guess_type(filename)
        if mime_type and mime_type.startswith('image/'):
            maintype, subtype = mime_type.split("/", 1)
        else:
            maintype, subtype = "image", "png"

        if maintype == "image":
            attachment = MIMEImage(data, subtype)
        else:
            attachment = MIMEBase(maintype, subtype)
            attachment.set_payload(data)
            encoders.encode_base64(attachment)

        if filename in cid_mapping:
            cid = cid_mapping[filename]
        else:
            existing_cid = getattr(att, 'cid', None) or getattr(att, 'contentId', None)
            if existing_cid:
                cid = existing_cid.strip('<>')
            else:
                cid = f"img_{hashlib.md5(filename.encode()).hexdigest()[:8]}"
        
        attachment.add_header("Content-ID", f"<{cid}>")
        attachment.add_header("Content-Disposition", "inline", filename=filename)
        
        parent.attach(attachment)

    def process_regular_attachment(self, att, outer):
        """Обработка обычных вложений"""
        filename = (getattr(att, 'longFilename', None) or 
                   getattr(att, 'shortFilename', None) or 
                   "attachment")
        
        data = getattr(att, 'data', None)
        if data is None:
            return
            
        if isinstance(data, str):
            data = data.encode(errors="replace")
        elif not isinstance(data, bytes):
            data = bytes(data)

        mime_type, _ = mimetypes.guess_type(filename)
        if mime_type:
            maintype, subtype = mime_type.split("/", 1)
        else:
            maintype, subtype = "application", "octet-stream"

        attachment = MIMEBase(maintype, subtype)
        attachment.set_payload(data)
        encoders.encode_base64(attachment)
        attachment.add_header("Content-Disposition", "attachment", filename=filename)
        attachment.add_header("Content-Transfer-Encoding", "base64")
        outer.attach(attachment)
    def convert_mbox_to_eml(self, mbox_path):
        try:
            messages = safe_mbox_loader(mbox_path)
            converted = []
            
            for i, msg in enumerate(messages, 1):
                try:
                    subject = decode_header_safe(msg.get('Subject', '')) or f'message_{i}'
                    safe_name = sanitize_filename(f"{i}_{subject}")
                    eml_path = os.path.join(self.output_dir, f"{safe_name}.eml")
                    
                    with open(eml_path, 'wb') as f:
                        f.write(msg.as_bytes())
                    
                    converted.append(eml_path)
                except Exception as e:
                    logger.error(f"Ошибка конвертации сообщения {i} из MBOX: {str(e)}")
                    continue
                    
            return converted
            
        except Exception as e:
            logger.error(f"Ошибка конвертации MBOX файла {mbox_path}: {str(e)}")
            raise

def load_config():
    default_config = {
        "output_dir": os.path.expanduser("~/EML_Export"),
        "dark_theme": True
    }

    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                config = json.load(f)
                for key in default_config:
                    if key in config:
                        default_config[key] = config[key]
        except Exception as e:
            logger.error(f"Ошибка загрузки конфигурации: {e}")

    return default_config

def save_config(config):
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=4)
    except Exception as e:
        logger.error(f"Ошибка сохранения конфигурации: {e}")

def detect_encoding(file_path):
    encodings = ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1', 'cp866', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read(1024)
            return encoding
        except UnicodeDecodeError:
            continue
    return 'utf-8'

def safe_mbox_loader(mbox_path):
    messages = []
    try:
        mbox = mailbox.mbox(mbox_path)
        return list(mbox)
    except UnicodeDecodeError:
        pass

    encoding = detect_encoding(mbox_path)
    try:
        with open(mbox_path, 'r', encoding=encoding, errors='replace') as f:
            content = f.read()
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.mbox', delete=False, encoding='utf-8') as tmp_file:
            tmp_file.write(content)
            tmp_path = tmp_file.name
        try:
            mbox = mailbox.mbox(tmp_path)
            messages = list(mbox)
        finally:
            os.unlink(tmp_path)
        return messages
    except Exception as e:
        try:
            return parse_mbox_manually(mbox_path, encoding)
        except:
            raise Exception(f"Не удалось загрузить MBOX файл: {str(e)}")

def parse_mbox_manually(mbox_path, encoding='utf-8'):
    messages = []
    with open(mbox_path, 'r', encoding=encoding, errors='replace') as f:
        content = f.read()
    parts = re.split(r'^From ', content, flags=re.MULTILINE)
    for i, part in enumerate(parts):
        if i == 0 and not part.strip():
            continue
        if i > 0:
            part = 'From ' + part
        try:
            msg = email.message_from_string(part)
            if msg.get('Subject') or msg.get('From'):
                messages.append(msg)
        except:
            continue
    return messages

def save_attachment(data, filename, parent=None):
    try:
        default_dir = os.path.join(os.path.expanduser("~"), "./")
        os.makedirs(default_dir, exist_ok=True)
        
        default_path = os.path.join(default_dir, filename)
        
        save_path, _ = QFileDialog.getSaveFileName(
            parent, 
            "Сохранить вложение", 
            default_path,  
            "Все файлы (*.*)"
        )
        if save_path:
            with open(save_path, "wb") as f:
                f.write(data)
            QMessageBox.information(parent, "Успех", f"Файл сохранён: {save_path}")
    except Exception as e:
        QMessageBox.warning(parent, "Ошибка", f"Не удалось сохранить: {str(e)}")

def save_attachments_bulk(attachments, parent=None):
    try:
        default_dir = os.path.join(os.path.expanduser("~"), "./")
        os.makedirs(default_dir, exist_ok=True)
        
        dir_path = QFileDialog.getExistingDirectory(
            parent, 
            "Выберите папку для сохранения",
            default_dir  
        )
        if dir_path:
            for name, data in attachments:
                path = os.path.join(dir_path, name)
                with open(path, "wb") as f:
                    f.write(data)
            QMessageBox.information(parent, "Успех", f"Вложения сохранены в: {dir_path}")
    except Exception as e:
        QMessageBox.warning(parent, "Ошибка", f"Не удалось сохранить вложения: {str(e)}")

def inline_cid_images(html, attachments):
    if not html or not attachments:
        return html

    def repl(match):
        src = match.group(1)
        if src.lower().startswith("cid:"):
            cid = src[4:]
            for att in attachments:
                att_cid = getattr(att, "cid", getattr(att, "contentId", None))
                if att_cid and att_cid.strip("<>") == cid:
                    data = att.data
                    mime_type, _ = mimetypes.guess_type(att.longFilename or att.shortFilename or "image.png")
                    if not mime_type:
                        mime_type = "image/png"
                    b64 = base64.b64encode(data).decode("utf-8")
                    return f'<img src="data:{mime_type};base64,{b64}">'
        return match.group(0)

    return re.sub(r'<img[^>]+src=["\']([^"\']+)["\'][^>]*>', repl, html, flags=re.IGNORECASE)

def sanitize_filename(filename):
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    filename = filename.strip('. ')
    if len(filename) > 100:
        filename = filename[:100]
    if not filename:
        filename = "no_subject"
    return filename

def decode_header_safe(header_value):
    if not header_value:
        return ""
    try:
        decoded_parts = decode_header(header_value)
        result = ""
        for part, encoding in decoded_parts:
            if isinstance(part, bytes):
                if encoding:
                    try:
                        result += part.decode(encoding)
                    except (UnicodeDecodeError, LookupError):
                        result += part.decode('utf-8', errors="replace")
                else:
                    for enc in ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1']:
                        try:
                            result += part.decode(enc)
                            break
                        except UnicodeDecodeError:
                            continue
                    else:
                        result += part.decode('utf-8', errors="replace")
            else:
                result += str(part)
        return result
    except:
        return str(header_value)

class DragDropListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setDragEnabled(False)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(QListWidget.DropOnly)
        self.setDefaultDropAction(Qt.CopyAction)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                file_path = url.toLocalFile()
                if file_path.lower().endswith(('.msg', '.mbox')):
                    self.addItem(file_path)
            event.acceptProposedAction()


class ConversionWorker(QThread):
    progress = pyqtSignal(int)
    error = pyqtSignal(str, str)
    finished = pyqtSignal()

    def __init__(self, files, output_dir, converter_instance):
        super().__init__()
        self.files = files
        self.output_dir = output_dir
        self.converter = converter_instance

    def run(self):
        total_files = len(self.files)
        for i, file_path in enumerate(self.files):
            try:
                if file_path.lower().endswith(".msg"):
                    self.converter.convert_msg_to_eml(file_path)
                elif file_path.lower().endswith(".mbox"):
                    self.converter.convert_mbox_to_eml(file_path)
            except Exception as e:
                self.error.emit(file_path, str(e))
            self.progress.emit(int((i + 1) / total_files * 100))
        self.finished.emit()


class PreviewDialog(QDialog):
    def __init__(self, title, msg_obj, msg_path, converter, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setFixedSize(900, 720)
        self.converter = converter
        self.msg_path = msg_path

        layout = QVBoxLayout(self)

        subject = getattr(msg_obj, "subject", "") or ""
        sender = getattr(msg_obj, "sender", "") or ""
        to = getattr(msg_obj, "to", "") or self.get_safe_recipients(getattr(msg_obj, "recipients", None))
        date = getattr(msg_obj, "date", "") or ""

        self.info_label = QLabel(
            f"<b>От:</b> {sender}<br><b>Кому:</b> {to}<br><b>Тема:</b> {subject}<br><b>Дата:</b> {date}"
        )
        self.info_label.setMaximumHeight(84)
        self.info_label.setWordWrap(True)
        layout.addWidget(self.info_label)

        switch_layout = QHBoxLayout()
        self.radio_text = QRadioButton("Текст")
        self.radio_html = QRadioButton("HTML")
        self.radio_text.setChecked(True)
        switch_layout.addWidget(self.radio_text)
        switch_layout.addWidget(self.radio_html)

        self.btn_convert = QPushButton("Конвертировать в EML")
        self.btn_convert.setObjectName("primaryButton")
        self.btn_convert.setToolTip("Сохранить это письмо как .eml")
        switch_layout.addStretch()
        switch_layout.addWidget(self.btn_convert)
        layout.addLayout(switch_layout)

        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setMaximumHeight(360)
        layout.addWidget(self.text_edit)

        layout.addWidget(QLabel("Вложения:"))
        self.attach_list = QListWidget()
        self.attach_list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.attach_list.setMaximumHeight(150)
        layout.addWidget(self.attach_list)

        btn_layout = QHBoxLayout()
        self.btn_save_one = QPushButton("Сохранить выбранное вложение")
        self.btn_save_all = QPushButton("Сохранить все вложения")
        btn_layout.addWidget(self.btn_save_one)
        btn_layout.addWidget(self.btn_save_all)
        layout.addLayout(btn_layout)

        self.body_text = getattr(msg_obj, "body", "") or ""
        self.body_html = getattr(msg_obj, "htmlBody", "") or b""

        self.attachments = []
        for att in msg_obj.attachments:
            name = att.longFilename or att.shortFilename or "attachment.bin"
            data = att.data
            self.attachments.append((name, data))
            self.attach_list.addItem(name)

        if self.body_html:
            if isinstance(self.body_html, bytes):
                html_str = self.body_html.decode("utf-8", errors="replace")
            else:
                html_str = str(self.body_html)
            self.body_html = inline_cid_images(html_str, msg_obj.attachments)

        self.update_body()

        self.radio_text.toggled.connect(self.update_body)
        self.btn_save_one.clicked.connect(self.save_selected_attachment)
        self.btn_save_all.clicked.connect(lambda: save_attachments_bulk(self.attachments, self))
        self.btn_convert.clicked.connect(self.convert_current_msg)

    def get_safe_recipients(self, recipients):
        if not recipients:
            return ""
        return ", ".join([getattr(r, "email", None) or getattr(r, "display_name", "Unknown") for r in recipients])

    def update_body(self):
        if self.radio_text.isChecked():
            if isinstance(self.body_text, bytes):
                text_str = self.body_text.decode("utf-8", errors="replace")
            else:
                text_str = str(self.body_text)
            self.text_edit.setPlainText(text_str[:10000])
        else:
            self.text_edit.setHtml(self.body_html if self.body_html else "<i>(Нет HTML-версии)</i>")

    def save_selected_attachment(self):
        item = self.attach_list.currentItem()
        if item:
            idx = self.attach_list.row(item)
            name, data = self.attachments[idx]
            save_attachment(data, name, self)

    def convert_current_msg(self):
        try:
            self.converter.convert_msg_to_eml(self.msg_path)
            base = os.path.basename(self.msg_path)
            QMessageBox.information(self, "Готово", f"Письмо '{base}' сконвертировано в EML и сохранено в:\n{self.converter.output_dir}")
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось конвертировать:\n{str(e)}")


class MboxPreviewDialog(QDialog):
    def __init__(self, mbox_path, converter, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"Предпросмотр MBOX: {os.path.basename(mbox_path)}")
        self.setFixedSize(1200, 720)
        self.converter = converter
        self.mbox_path = mbox_path

        layout = QHBoxLayout(self)
        self.list_widget = QListWidget()
        layout.addWidget(self.list_widget, 3)

        right_layout = QVBoxLayout()
        self.info_label = QLabel("Выберите письмо из списка")
        self.info_label.setMaximumHeight(84)
        self.info_label.setWordWrap(True)
        right_layout.addWidget(self.info_label)

        switch_layout = QHBoxLayout()
        self.radio_text = QRadioButton("Текст")
        self.radio_html = QRadioButton("HTML")
        self.radio_text.setChecked(True)
        switch_layout.addWidget(self.radio_text)
        switch_layout.addWidget(self.radio_html)

        self.btn_convert_one = QPushButton("Конвертировать выбранное письмо")
        self.btn_convert_one.setObjectName("primaryButton")
        self.btn_convert_one.setToolTip("Сохранить текущее письмо как .eml")

        self.btn_convert_all = QPushButton("Конвертировать все письма MBOX")
        self.btn_convert_all.setObjectName("primaryButton")
        self.btn_convert_all.setToolTip("Сохранить весь MBOX в виде набора .eml")

        switch_layout.addStretch()
        switch_layout.addWidget(self.btn_convert_one)
        switch_layout.addWidget(self.btn_convert_all)
        right_layout.addLayout(switch_layout)

        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setMinimumHeight(360)
        self.text_edit.setMaximumHeight(400)
        right_layout.addWidget(self.text_edit)

        right_layout.addWidget(QLabel("Вложения:"))
        self.attach_list = QListWidget()
        self.attach_list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.attach_list.setMaximumHeight(120)
        right_layout.addWidget(self.attach_list)

        btn_layout = QHBoxLayout()
        self.btn_save_one = QPushButton("Сохранить выбранное")
        self.btn_save_all = QPushButton("Сохранить все")
        btn_layout.addWidget(self.btn_save_one)
        btn_layout.addWidget(self.btn_save_all)
        right_layout.addLayout(btn_layout)

        layout.addLayout(right_layout, 7)

        try:
            self.messages = safe_mbox_loader(mbox_path)
            if not self.messages:
                QMessageBox.warning(parent, "Предупреждение", "MBOX файл не содержит писем или поврежден")
                return
            for i, msg in enumerate(self.messages, start=1):
                try:
                    subject = decode_header_safe(msg.get("Subject", "")) or "(без темы)"
                    sender = decode_header_safe(msg.get("From", "")) or "(без отправителя)"
                    if len(subject) > 50:
                        subject = subject[:47] + "..."
                    if len(sender) > 30:
                        sender = sender[:27] + "..."
                    item = QListWidgetItem(f"{i}. {subject} — {sender}")
                    item.setData(Qt.UserRole, i - 1)
                    self.list_widget.addItem(item)
                except Exception:
                    item = QListWidgetItem(f"{i}. (ошибка декодирования письма)")
                    item.setData(Qt.UserRole, i - 1)
                    self.list_widget.addItem(item)
        except Exception as e:
            QMessageBox.warning(parent, "Ошибка", f"Не удалось загрузить MBOX файл:\n{str(e)}")
            self.messages = []

        self.list_widget.itemClicked.connect(self.show_message)
        self.radio_text.toggled.connect(self.update_body)
        self.btn_save_one.clicked.connect(self.save_selected_attachment)
        self.btn_save_all.clicked.connect(self.save_all_attachments)
        self.btn_convert_one.clicked.connect(self.convert_selected_message)
        self.btn_convert_all.clicked.connect(self.convert_all_messages_from_dialog)

        self.current_body_text = ""
        self.current_body_html = ""
        self.attachments = []

    def decode_header_safe(self, header_value):
        return decode_header_safe(header_value)

    def decode_payload_safe(self, part):
        """Безопасное декодирование содержимого письма"""
        try:
            payload = part.get_payload(decode=True)
            if isinstance(payload, bytes):
                charset = part.get_content_charset()
                if charset:
                    try:
                        return payload.decode(charset)
                    except (UnicodeDecodeError, LookupError):
                        pass
                for encoding in ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1', 'cp866']:
                    try:
                        return payload.decode(encoding)
                    except UnicodeDecodeError:
                        continue
                return payload.decode('utf-8', errors='replace')
            else:
                return str(payload)
        except:
            try:
                payload = part.get_payload()
                return str(payload)
            except:
                return "(не удалось декодировать содержимое)"

    def show_message(self, item):
        index = item.data(Qt.UserRole)
        if index >= len(self.messages):
            self.info_label.setText("Ошибка: письмо не найдено")
            return
            
        msg = self.messages[index]
        try:
            subject = self.decode_header_safe(msg.get("Subject", ""))
            sender = self.decode_header_safe(msg.get("From", ""))
            to = self.decode_header_safe(msg.get("To", ""))
            date = self.decode_header_safe(msg.get("Date", ""))
        except Exception:
            subject = sender = to = date = "(ошибка декодирования)"
            
        self.info_label.setText(
            f"<b>От:</b> {sender}<br>"
            f"<b>Кому:</b> {to}<br>"
            f"<b>Тема:</b> {subject}<br>"
            f"<b>Дата:</b> {date}"
        )

        text, html = "", ""
        attachments = []
        
        try:
            if msg.is_multipart():
                for part in msg.walk():
                    try:
                        ctype = part.get_content_type()
                        disp = str(part.get("Content-Disposition", "")).lower()
                        
                        if ctype == "text/plain" and "attachment" not in disp:
                            text = self.decode_payload_safe(part)
                        elif ctype == "text/html" and "attachment" not in disp:
                            html = self.decode_payload_safe(part)
                        elif "attachment" in disp or part.get_filename():
                            fname = part.get_filename() or "attachment.bin"
                            fname = self.decode_header_safe(fname)
                            try:
                                data = part.get_payload(decode=True)
                                if data:
                                    attachments.append((fname, data))
                            except:
                                pass
                    except Exception:
                        continue
            else:
                text = self.decode_payload_safe(msg)
        except Exception as e:
            text = f"(Ошибка декодирования содержимого: {str(e)})"

        self.current_body_text = text
        self.current_body_html = html
        self.attachments = attachments
        
        self.attach_list.clear()
        for fname, _ in attachments:
            self.attach_list.addItem(fname)
            
        self.update_body()

    def update_body(self):
        if self.radio_text.isChecked():
            self.text_edit.setPlainText(self.current_body_text[:10000])
        else:
            self.text_edit.setHtml(self.current_body_html if self.current_body_html else "<i>(Нет HTML-версии)</i>")

    def save_selected_attachment(self):
        item = self.attach_list.currentItem()
        if item:
            idx = self.attach_list.row(item)
            name, data = self.attachments[idx]
            save_attachment(data, name, self)

    def save_all_attachments(self):
        if self.attachments:
            save_attachments_bulk(self.attachments, self)
        else:
            QMessageBox.information(self, "Информация", "Нет вложений для сохранения")

    def convert_selected_message(self):
        item = self.list_widget.currentItem()
        if not item:
            QMessageBox.warning(self, "Нет выбора", "Выберите письмо слева в списке.")
            return
        
        idx = item.data(Qt.UserRole)
        if idx is None or idx >= len(self.messages):
            QMessageBox.warning(self, "Ошибка", "Неверный индекс письма.")
            return
            
        try:
            msg = self.messages[idx]
            subject = decode_header_safe(msg.get("Subject", "")) or f"message_{idx+1:03d}"
            clean_subject = sanitize_filename(subject)
            
            eml_name = f"{clean_subject}.eml"
            eml_path = os.path.join(self.converter.output_dir, eml_name)
            
            counter = 1
            while os.path.exists(eml_path):
                eml_name = f"{clean_subject}_{counter}.eml"
                eml_path = os.path.join(self.converter.output_dir, eml_name)
                counter += 1
            
            Path(self.converter.output_dir).mkdir(parents=True, exist_ok=True)
            
            with open(eml_path, 'wb') as f:
                generator = email.generator.BytesGenerator(f, policy=email.policy.SMTP)
                generator.flatten(msg)
                
            QMessageBox.information(self, "Готово", 
                                  f"Письмо сохранено как:\n{eml_path}")
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", 
                             f"Не удалось конвертировать письмо:\n{str(e)}")

    def convert_all_messages_from_dialog(self):
        try:
            Path(self.converter.output_dir).mkdir(parents=True, exist_ok=True)
            converted = 0
            
            for i, msg in enumerate(self.messages):
                try:
                    subject = decode_header_safe(msg.get("Subject", "")) or f"message_{i+1:03d}"
                    clean_subject = sanitize_filename(subject)
                    
                    eml_name = f"{clean_subject}.eml"
                    eml_path = os.path.join(self.converter.output_dir, eml_name)
                    
                    counter = 1
                    while os.path.exists(eml_path):
                        eml_name = f"{clean_subject}_{counter}.eml"
                        eml_path = os.path.join(self.converter.output_dir, eml_name)
                        counter += 1
                    
                    with open(eml_path, 'wb') as f:
                        generator = email.generator.BytesGenerator(f, policy=email.policy.SMTP)
                        generator.flatten(msg)
                    converted += 1
                    
                except Exception as e:
                    logger.error(f"Ошибка конвертации письма {i+1}: {str(e)}")
                    continue
            
            QMessageBox.information(self, "Готово", 
                f"Сконвертировано писем: {converted}\nПапка: {self.converter.output_dir}")
                
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", 
                f"Ошибка при конвертации писем:\n{str(e)}")



class MsgToEmlConverter(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MSG and MBOX → EML Конвертер")
        self.resize(650, 500)

        self.config = load_config()
        self.output_dir = self.config["output_dir"]
        
        self.converter = MessageConverter(self.output_dir)

        self.conversion_worker = None
        
        self.init_ui()

        if self.config.get("light_theme", True):
            self.set_light_theme()
            self.theme_checkbox.setChecked(False)
        else:
            self.set_dark_theme()
            self.theme_checkbox.setChecked(True)


    def preview_selected_file(self):
        current_item = self.list_widget.currentItem()
        if current_item:
            self.preview_file(current_item)
        else:
            QMessageBox.warning(self, "Предупреждение", "Выберите файл для предпросмотра")

    def preview_file(self, item):
        file_path = item.text()
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "Ошибка", "Файл не найден")
            return

        try:
            if file_path.lower().endswith('.msg'):
                msg = extract_msg.Message(file_path)
                dialog = PreviewDialog("Предпросмотр MSG", msg, file_path, self.converter, self)
                dialog.exec_()
            elif file_path.lower().endswith('.mbox'):
                dialog = MboxPreviewDialog(file_path, self.converter, self)
                dialog.exec_()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось открыть файл:\n{str(e)}")

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        top_bar = QHBoxLayout()
        self.label = QLabel("Перетащите файлы .msg или .mbox, или выберите вручную:")
        top_bar.addWidget(self.label)

        self.preview_button = QPushButton("📋 Предпросмотр")
        self.preview_button.setToolTip("Открыть предпросмотр для выделенного файла")
        self.preview_button.clicked.connect(self.preview_selected_file)
        top_bar.addWidget(self.preview_button)

        self.settings_button = QToolButton()
        self.settings_button.setIcon(QIcon.fromTheme("preferences-system"))
        self.settings_button.setPopupMode(QToolButton.InstantPopup)
        self.setup_settings_menu()
        top_bar.addStretch()
        top_bar.addWidget(self.settings_button)
        layout.addLayout(top_bar)

        self.list_widget = DragDropListWidget()
        self.list_widget.itemDoubleClicked.connect(self.preview_file)
        layout.addWidget(self.list_widget)

        btn_layout = QHBoxLayout()
        self.clear_button = QPushButton("🗑️ Очистить список")
        self.clear_button.clicked.connect(self.list_widget.clear)
        btn_layout.addStretch()
        btn_layout.addWidget(self.clear_button)
        layout.addLayout(btn_layout)

        self.select_button = QPushButton("Выбрать MSG-файлы")
        self.select_button.clicked.connect(self.select_files)
        layout.addWidget(self.select_button)

        self.mbox_button = QPushButton("Выбрать MBOX-файлы")
        self.mbox_button.clicked.connect(self.select_mbox_files)
        layout.addWidget(self.mbox_button)

        self.convert_button = QPushButton("Конвертировать")
        self.convert_button.setObjectName("primaryButton")
        self.convert_button.clicked.connect(self.convert_all)
        layout.addWidget(self.convert_button)

        self.output_info = QLabel(f"Файлы будут сохранены в: {self.output_dir}")
        layout.addWidget(self.output_info)

        self.progress = QProgressBar()
        self.progress.setAlignment(Qt.AlignCenter)
        self.progress.setFormat("%p%")
        layout.addWidget(self.progress)

        mk_label = QLabel("MK")
        mk_label.setAlignment(Qt.AlignRight | Qt.AlignBottom)
        mk_label.setStyleSheet("color: gray; padding: 1px;")
        layout.addWidget(mk_label)        

    def preview_selected_file(self):
        """Предпросмотр выбранного файла"""
        current_item = self.list_widget.currentItem()
        if current_item:
            self.preview_file(current_item)
        else:
            QMessageBox.warning(self, "Предупреждение", "Выберите файл для предпросмотра")

    def preview_file(self, item):
        file_path = item.text()
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "Ошибка", "Файл не найден")
            return

        try:
            if file_path.lower().endswith('.msg'):
                msg = extract_msg.Message(file_path)
                dialog = PreviewDialog("Предпросмотр MSG", msg, file_path, self.converter, self)
                dialog.exec_()
            elif file_path.lower().endswith('.mbox'):
                dialog = MboxPreviewDialog(file_path, self.converter, self)
                dialog.exec_()
        except Exception as e:
            QMessageBox.critical(self, "Ошибка", f"Не удалось открыть файл:\n{str(e)}")

    def setup_settings_menu(self):
        menu = QMenu(self)
        
        self.theme_checkbox = QAction("Тёмная тема", menu)
        self.theme_checkbox.setCheckable(True)
        self.theme_checkbox.toggled.connect(self.toggle_theme)
        menu.addAction(self.theme_checkbox)
        
        change_output = QAction("Изменить папку сохранения", menu)
        change_output.triggered.connect(self.select_output_dir)
        menu.addAction(change_output)
        
        self.settings_button.setMenu(menu)

    def toggle_theme(self, checked):
        if checked:
            self.set_dark_theme()
        else:
            self.set_light_theme()
        self.config["dark_theme"] = checked
        save_config(self.config)

    def set_dark_theme(self):
        app = QApplication.instance()
        app.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QPushButton {
                background-color: #3b3b3b;
                border: 1px solid #555555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #454545;
            }
            QPushButton#primaryButton {
                background-color: #0d47a1;
            }
            QPushButton#primaryButton:hover {
                background-color: #1565c0;
            }
            QListWidget {
                border: 1px solid #555555;
            }
            QProgressBar {
                border: 1px solid #555555;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #0d47a1;
            }
        """)

    def set_light_theme(self):
        app = QApplication.instance()
        app.setStyleSheet("""
            QWidget {
                background-color: #f0f0f0;
                color: #000000;
            }
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #e6e6e6;
            }
            QPushButton#primaryButton {
                background-color: #1976d2;
                color: white;
            }
            QPushButton#primaryButton:hover {
                background-color: #1565c0;
            }
            QListWidget {
                border: 1px solid #cccccc;
            }
            QProgressBar {
                border: 1px solid #cccccc;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #1976d2;
            }
        """)

    def select_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self, "Выберите MSG файлы", 
            os.path.expanduser("~"),  # Начинать с домашнего каталога
            "MSG файлы (*.msg);;Все файлы (*.*)"
        )
        if files:
            self.list_widget.addItems(files)

    def select_mbox_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self, "Выберите MBOX файлы", 
            os.path.expanduser("~"),  # Начинать с домашнего каталога
            "MBOX файлы (*.mbox *.mbx);;Все файлы (*.*)"
        )
        if files:
            self.list_widget.addItems(files)

    def select_output_dir(self):
        dir_path = QFileDialog.getExistingDirectory(
            self, "Выберите папку для сохранения",
            self.output_dir
        )
        if dir_path:
            self.output_dir = dir_path
            self.output_info.setText(f"Файлы будут сохранены в: {self.output_dir}")
            self.config["output_dir"] = dir_path
            save_config(self.config)

    def convert_all(self):
        files = [self.list_widget.item(i).text() for i in range(self.list_widget.count())]
        if not files:
            QMessageBox.warning(self, "Предупреждение", "Добавьте файлы для конвертации")
            return

        os.makedirs(self.output_dir, exist_ok=True)
        
        self.conversion_worker = ConversionWorker(files, self.output_dir, self.converter)
        self.conversion_worker.progress.connect(self.progress.setValue)
        self.conversion_worker.error.connect(self.show_error)
        self.conversion_worker.finished.connect(self.conversion_finished)
        
        self.convert_button.setEnabled(False)
        self.progress.setValue(0)
        self.conversion_worker.start()

    def show_error(self, file_path, error_msg):
        QMessageBox.warning(
            self, "Ошибка конвертации",
            f"Ошибка при конвертации {file_path}:\n{error_msg}"
        )

    def conversion_finished(self):
        self.convert_button.setEnabled(True)
        self.progress.setValue(100)
        QMessageBox.information(
            self, "Готово",
            f"Конвертация завершена.\nФайлы сохранены в:\n{self.output_dir}"
        )

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.setApplicationName("MSG AND MBOX to EML Converter")
    window = MsgToEmlConverter()
    window.show()
    sys.exit(app.exec_())
