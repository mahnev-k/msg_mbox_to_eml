import sys
import os
import mimetypes
import extract_msg
import mailbox
import email
import subprocess
import logging
import re
import hashlib
import time
import base64
import codecs
import json
from pathlib import Path
from datetime import datetime
from email.utils import formatdate, parsedate_tz, mktime_tz
from email.header import decode_header, Header
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email.mime.image import MIMEImage
from email import encoders
from email.message import EmailMessage
from PyQt5.QtWidgets import (
    QApplication, QWidget, QVBoxLayout, QLabel, QPushButton, QFileDialog,
    QListWidget, QMessageBox, QProgressBar, QHBoxLayout, QToolButton, QMenu,
    QAction, QDialog, QTextEdit, QListWidgetItem, QRadioButton,
    QAbstractItemView
)
from PyQt5.QtCore import Qt, QThread, pyqtSignal
from PyQt5.QtGui import QIcon

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

CONFIG_FILE = os.path.join(os.path.expanduser("~"), ".msg_to_eml_config.json")

class MessageConverter:
    def generate_safe_filename(self, original_path, new_extension):
        base_name = os.path.splitext(os.path.basename(original_path))[0]
        safe_name = sanitize_filename(base_name)
        
        if not safe_name:
            safe_name = "converted_message"
        
        return safe_name + new_extension

    def parse_msg_date(self, date_obj):
        """–ü–∞—Ä—Å–∏–Ω–≥ –¥–∞—Ç—ã –∏–∑ MSG –æ–±—ä–µ–∫—Ç–∞"""
        if date_obj is None:
            return datetime.now()
            
        if isinstance(date_obj, datetime):
            return date_obj
            
        if isinstance(date_obj, str):
            try:
                for fmt in ['%a, %d %b %Y %H:%M:%S %z', '%d %b %Y %H:%M:%S', '%Y-%m-%d %H:%M:%S']:
                    try:
                        return datetime.strptime(date_obj, fmt)
                    except ValueError:
                        continue
            except:
                pass
        
        return datetime.now()

    def process_html_with_inline_images(self, html, inline_attachments, cid_mapping):

        if not html or not inline_attachments:
            return html

        if isinstance(html, bytes):
            html = html.decode('utf-8', errors='replace')

        def repl(match):
            src = match.group(1)
            if src.lower().startswith("cid:"):
                cid = src[4:].strip('<>')
                
                for att in inline_attachments:
                    att_cid = getattr(att, 'cid', None) or getattr(att, 'contentId', None)
                    if att_cid and att_cid.strip('<>') == cid:
                        filename = (getattr(att, 'longFilename', None) or 
                                getattr(att, 'shortFilename', None) or 
                                f"image_{hashlib.md5(cid.encode()).hexdigest()[:8]}")
                        
                        cid_mapping[filename] = cid
                        
                        return f'src="cid:{cid}"'
            
            return match.group(0)

        return re.sub(r'src=["\']cid:([^"\']+)["\']', repl, html, flags=re.IGNORECASE)

    def is_inline_attachment(self, attachment):

        try:
            cid = getattr(attachment, 'cid', None) or getattr(attachment, 'contentId', None)
            if cid:
                return True
                
            content_disposition = getattr(attachment, 'contentDisposition', '') or ''
            if 'inline' in content_disposition.lower():
                return True
                
            filename = (getattr(attachment, 'longFilename', None) or 
                    getattr(attachment, 'shortFilename', None) or '')
            if filename.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp')):
                return True
                
            mime_type = getattr(attachment, 'mimeType', None)
            if mime_type and mime_type.startswith('image/'):
                return True
                
        except Exception:
            pass
            
        return False

    def decode_text(self, text):
      if text is None:
            return ""
        
      if isinstance(text, bytes):
            try:
                for encoding in ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1', 'cp866']:
                    try:
                        return text.decode(encoding)
                    except UnicodeDecodeError:
                        continue
                return text.decode('utf-8', errors='replace')
            except Exception:
                return str(text)
      else:
           return str(text)

    def get_safe_recipients(self, recipients):

        if not recipients:
            return ""
        
        recipient_list = []
        for recipient in recipients:
            if hasattr(recipient, 'email') and recipient.email:
                recipient_list.append(recipient.email)
            elif hasattr(recipient, 'display_name') and recipient.display_name:
                recipient_list.append(recipient.display_name)
            elif isinstance(recipient, str):
                recipient_list.append(recipient)
            else:
                try:
                    recipient_list.append(str(recipient))
                except:
                    recipient_list.append("Unknown")
        
        return ", ".join(recipient_list)

    def __init__(self, output_dir):
        self.output_dir = output_dir

    def encode_header(self, text):
        if not text:
            return ""
        try:
            if isinstance(text, bytes):
                text = text.decode('utf-8', errors='replace')
            if any(ord(c) > 127 for c in text):
                from email.header import Header
                return str(Header(text, 'utf-8'))
            return text
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–≥–æ–ª–æ–≤–∫–∞: {e}")
            return str(text)

    def convert_msg_to_eml(self, msg_path):
        try:
            msg = extract_msg.Message(msg_path)
            
            msg_sender = getattr(msg, 'sender', None) or ""
            recipients = getattr(msg, 'recipients', None)
            if recipients is None:
              recipients = getattr(msg, 'to', None) or getattr(msg, 'display_to', None)
            msg_to = self.get_safe_recipients(recipients) if recipients else ""
            msg_subject = getattr(msg, 'subject', None) or ""
            msg_body = self.decode_text(getattr(msg, 'body', None))
            msg_html = self.decode_text(getattr(msg, 'htmlBody', None))

            attachments = getattr(msg, 'attachments', [])
            inline_attachments = []
            regular_attachments = []
            cid_mapping = {} 

            for att in attachments:
                if self.is_inline_attachment(att):
                    inline_attachments.append(att)
                else:
                    regular_attachments.append(att)

            if msg_html and inline_attachments:
                msg_html = self.process_html_with_inline_images(msg_html, inline_attachments, cid_mapping)

            if not msg_body and not msg_html:
                outer = email.mime.text.MIMEText("", "plain", "utf-8")
            elif msg_html and not msg_body:
                if inline_attachments:
                    outer = MIMEMultipart("related")
                    html_part = MIMEText(msg_html, "html", "utf-8")
                    outer.attach(html_part)
                    
                    for att in inline_attachments:
                        self.process_inline_attachment(att, outer, cid_mapping)
                else:
                    outer = MIMEText(msg_html, "html", "utf-8")
            elif msg_body and not msg_html:
                outer = MIMEText(msg_body, "plain", "utf-8")
            else:
                if inline_attachments:
                    outer = MIMEMultipart("alternative")
                    
                    text_part = MIMEText(msg_body, "plain", "utf-8")
                    outer.attach(text_part)
                    
                    html_related = MIMEMultipart("related")
                    html_part = MIMEText(msg_html, "html", "utf-8")
                    html_related.attach(html_part)
                    
                    for att in inline_attachments:
                        self.process_inline_attachment(att, html_related, cid_mapping)
                    
                    outer.attach(html_related)
                else:
                    outer = MIMEMultipart("alternative")
                    outer.attach(MIMEText(msg_body, "plain", "utf-8"))
                    outer.attach(MIMEText(msg_html, "html", "utf-8"))

            if regular_attachments:
                if isinstance(outer, MIMEMultipart):
                    mixed_outer = MIMEMultipart("mixed")
                    for key, value in outer.items():
                        mixed_outer[key] = value
                    mixed_outer.attach(outer)
                else:
                    mixed_outer = MIMEMultipart("mixed")
                    for key, value in outer.items():
                        mixed_outer[key] = value
                    mixed_outer.attach(outer)
                
                outer = mixed_outer

                for att in regular_attachments:
                    try:
                        self.process_regular_attachment(att, outer)
                    except Exception as e:
                        logger.warning(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –≤–ª–æ–∂–µ–Ω–∏—è: {str(e)}")
                        continue

            outer["Subject"] = msg_subject
            outer["From"] = msg_sender
            outer["To"] = msg_to
            outer["Message-ID"] = f"<{hash(msg_path)}@converted.local>"
            
            msg_date = None
            if hasattr(msg, 'date') and msg.date:
                msg_date = self.parse_msg_date(msg.date)
            else:
                for attr in ['creationTime', 'lastModificationTime', 'receivedTime']:
                    if hasattr(msg, attr):
                        attr_value = getattr(msg, attr)
                        if attr_value:
                            msg_date = self.parse_msg_date(attr_value)
                            break

            if not msg_date:
                msg_date = datetime.now()

            try:
                formatted_date = formatdate(msg_date.timestamp(), localtime=True)
            except:
                formatted_date = formatdate(time.time(), localtime=True)

            outer["Date"] = formatted_date

            outer["MIME-Version"] = "1.0"

            out_filename = self.generate_safe_filename(msg_path, ".eml")
            out_path = os.path.join(self.output_dir, out_filename)
            
            with open(out_path, "w", encoding="utf-8", newline='\n') as f:
                f.write(outer.as_string())

            logger.info(f"–£—Å–ø–µ—à–Ω–æ –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω: {msg_path} -> {out_path}")
            return out_path

        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ MSG —Ñ–∞–π–ª–∞ {msg_path}: {str(e)}")
            raise

    def process_inline_attachment(self, att, parent, cid_mapping):
        filename = (getattr(att, 'longFilename', None) or 
                   getattr(att, 'shortFilename', None) or 
                   "inline_image")
        
        data = getattr(att, 'data', None)
        if data is None:
            return
            
        if isinstance(data, str):
            data = data.encode(errors="replace")
        elif not isinstance(data, bytes):
            data = bytes(data)

        mime_type, _ = mimetypes.guess_type(filename)
        if mime_type and mime_type.startswith('image/'):
            maintype, subtype = mime_type.split("/", 1)
        else:
            maintype, subtype = "image", "png"

        if maintype == "image":
            attachment = MIMEImage(data, subtype)
        else:
            attachment = MIMEBase(maintype, subtype)
            attachment.set_payload(data)
            encoders.encode_base64(attachment)

        if filename in cid_mapping:
            cid = cid_mapping[filename]
        else:
            existing_cid = getattr(att, 'cid', None) or getattr(att, 'contentId', None)
            if existing_cid:
                cid = existing_cid.strip('<>')
            else:
                cid = f"img_{hashlib.md5(filename.encode()).hexdigest()[:8]}"
        
        attachment.add_header("Content-ID", f"<{cid}>")
        attachment.add_header("Content-Disposition", "inline", filename=filename)
        
        parent.attach(attachment)

    def process_regular_attachment(self, att, outer):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ–±—ã—á–Ω—ã—Ö –≤–ª–æ–∂–µ–Ω–∏–π"""
        filename = (getattr(att, 'longFilename', None) or 
                   getattr(att, 'shortFilename', None) or 
                   "attachment")
        
        data = getattr(att, 'data', None)
        if data is None:
            return
            
        if isinstance(data, str):
            data = data.encode(errors="replace")
        elif not isinstance(data, bytes):
            data = bytes(data)

        mime_type, _ = mimetypes.guess_type(filename)
        if mime_type:
            maintype, subtype = mime_type.split("/", 1)
        else:
            maintype, subtype = "application", "octet-stream"

        attachment = MIMEBase(maintype, subtype)
        attachment.set_payload(data)
        encoders.encode_base64(attachment)
        attachment.add_header("Content-Disposition", "attachment", filename=filename)
        attachment.add_header("Content-Transfer-Encoding", "base64")
        outer.attach(attachment)
    def convert_mbox_to_eml(self, mbox_path):
        try:
            messages = safe_mbox_loader(mbox_path)
            converted = []
            
            for i, msg in enumerate(messages, 1):
                try:
                    subject = decode_header_safe(msg.get('Subject', '')) or f'message_{i}'
                    safe_name = sanitize_filename(f"{i}_{subject}")
                    eml_path = os.path.join(self.output_dir, f"{safe_name}.eml")
                    
                    with open(eml_path, 'wb') as f:
                        f.write(msg.as_bytes())
                    
                    converted.append(eml_path)
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è {i} –∏–∑ MBOX: {str(e)}")
                    continue
                    
            return converted
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ MBOX —Ñ–∞–π–ª–∞ {mbox_path}: {str(e)}")
            raise

def load_config():
    default_config = {
        "output_dir": os.path.expanduser("~/EML_Export"),
        "dark_theme": True
    }

    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                config = json.load(f)
                for key in default_config:
                    if key in config:
                        default_config[key] = config[key]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")

    return default_config

def save_config(config):
    try:
        with open(CONFIG_FILE, 'w', encoding='utf-8') as f:
            json.dump(config, f, ensure_ascii=False, indent=4)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}")

def detect_encoding(file_path):
    encodings = ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1', 'cp866', 'latin1']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as f:
                f.read(1024)
            return encoding
        except UnicodeDecodeError:
            continue
    return 'utf-8'

def safe_mbox_loader(mbox_path):
    messages = []
    try:
        mbox = mailbox.mbox(mbox_path)
        return list(mbox)
    except UnicodeDecodeError:
        pass

    encoding = detect_encoding(mbox_path)
    try:
        with open(mbox_path, 'r', encoding=encoding, errors='replace') as f:
            content = f.read()
        import tempfile
        with tempfile.NamedTemporaryFile(mode='w', suffix='.mbox', delete=False, encoding='utf-8') as tmp_file:
            tmp_file.write(content)
            tmp_path = tmp_file.name
        try:
            mbox = mailbox.mbox(tmp_path)
            messages = list(mbox)
        finally:
            os.unlink(tmp_path)
        return messages
    except Exception as e:
        try:
            return parse_mbox_manually(mbox_path, encoding)
        except:
            raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å MBOX —Ñ–∞–π–ª: {str(e)}")

def parse_mbox_manually(mbox_path, encoding='utf-8'):
    messages = []
    with open(mbox_path, 'r', encoding=encoding, errors='replace') as f:
        content = f.read()
    parts = re.split(r'^From ', content, flags=re.MULTILINE)
    for i, part in enumerate(parts):
        if i == 0 and not part.strip():
            continue
        if i > 0:
            part = 'From ' + part
        try:
            msg = email.message_from_string(part)
            if msg.get('Subject') or msg.get('From'):
                messages.append(msg)
        except:
            continue
    return messages

def save_attachment(data, filename, parent=None):
    try:
        default_dir = os.path.join(os.path.expanduser("~"), "./")
        os.makedirs(default_dir, exist_ok=True)
        
        default_path = os.path.join(default_dir, filename)
        
        save_path, _ = QFileDialog.getSaveFileName(
            parent, 
            "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–ª–æ–∂–µ–Ω–∏–µ", 
            default_path,  
            "–í—Å–µ —Ñ–∞–π–ª—ã (*.*)"
        )
        if save_path:
            with open(save_path, "wb") as f:
                f.write(data)
            QMessageBox.information(parent, "–£—Å–ø–µ—Ö", f"–§–∞–π–ª —Å–æ—Ö—Ä–∞–Ω—ë–Ω: {save_path}")
    except Exception as e:
        QMessageBox.warning(parent, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å: {str(e)}")

def save_attachments_bulk(attachments, parent=None):
    try:
        default_dir = os.path.join(os.path.expanduser("~"), "./")
        os.makedirs(default_dir, exist_ok=True)
        
        dir_path = QFileDialog.getExistingDirectory(
            parent, 
            "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–ø–∫—É –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è",
            default_dir  
        )
        if dir_path:
            for name, data in attachments:
                path = os.path.join(dir_path, name)
                with open(path, "wb") as f:
                    f.write(data)
            QMessageBox.information(parent, "–£—Å–ø–µ—Ö", f"–í–ª–æ–∂–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤: {dir_path}")
    except Exception as e:
        QMessageBox.warning(parent, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–ª–æ–∂–µ–Ω–∏—è: {str(e)}")

def inline_cid_images(html, attachments):
    if not html or not attachments:
        return html

    def repl(match):
        src = match.group(1)
        if src.lower().startswith("cid:"):
            cid = src[4:]
            for att in attachments:
                att_cid = getattr(att, "cid", getattr(att, "contentId", None))
                if att_cid and att_cid.strip("<>") == cid:
                    data = att.data
                    mime_type, _ = mimetypes.guess_type(att.longFilename or att.shortFilename or "image.png")
                    if not mime_type:
                        mime_type = "image/png"
                    b64 = base64.b64encode(data).decode("utf-8")
                    return f'<img src="data:{mime_type};base64,{b64}">'
        return match.group(0)

    return re.sub(r'<img[^>]+src=["\']([^"\']+)["\'][^>]*>', repl, html, flags=re.IGNORECASE)

def sanitize_filename(filename):
    invalid_chars = '<>:"/\\|?*'
    for char in invalid_chars:
        filename = filename.replace(char, '_')
    filename = filename.strip('. ')
    if len(filename) > 100:
        filename = filename[:100]
    if not filename:
        filename = "no_subject"
    return filename

def decode_header_safe(header_value):
    if not header_value:
        return ""
    try:
        decoded_parts = decode_header(header_value)
        result = ""
        for part, encoding in decoded_parts:
            if isinstance(part, bytes):
                if encoding:
                    try:
                        result += part.decode(encoding)
                    except (UnicodeDecodeError, LookupError):
                        result += part.decode('utf-8', errors="replace")
                else:
                    for enc in ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1']:
                        try:
                            result += part.decode(enc)
                            break
                        except UnicodeDecodeError:
                            continue
                    else:
                        result += part.decode('utf-8', errors="replace")
            else:
                result += str(part)
        return result
    except:
        return str(header_value)

class DragDropListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAcceptDrops(True)
        self.setDragEnabled(False)
        self.setDropIndicatorShown(True)
        self.setDragDropMode(QListWidget.DropOnly)
        self.setDefaultDropAction(Qt.CopyAction)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dragMoveEvent(self, event):
        if event.mimeData().hasUrls():
            event.acceptProposedAction()

    def dropEvent(self, event):
        if event.mimeData().hasUrls():
            for url in event.mimeData().urls():
                file_path = url.toLocalFile()
                if file_path.lower().endswith(('.msg', '.mbox')):
                    self.addItem(file_path)
            event.acceptProposedAction()


class ConversionWorker(QThread):
    progress = pyqtSignal(int)
    error = pyqtSignal(str, str)
    finished = pyqtSignal()

    def __init__(self, files, output_dir, converter_instance):
        super().__init__()
        self.files = files
        self.output_dir = output_dir
        self.converter = converter_instance

    def run(self):
        total_files = len(self.files)
        for i, file_path in enumerate(self.files):
            try:
                if file_path.lower().endswith(".msg"):
                    self.converter.convert_msg_to_eml(file_path)
                elif file_path.lower().endswith(".mbox"):
                    self.converter.convert_mbox_to_eml(file_path)
            except Exception as e:
                self.error.emit(file_path, str(e))
            self.progress.emit(int((i + 1) / total_files * 100))
        self.finished.emit()


class PreviewDialog(QDialog):
    def __init__(self, title, msg_obj, msg_path, converter, parent=None):
        super().__init__(parent)
        self.setWindowTitle(title)
        self.setFixedSize(900, 720)
        self.converter = converter
        self.msg_path = msg_path

        layout = QVBoxLayout(self)

        subject = getattr(msg_obj, "subject", "") or ""
        sender = getattr(msg_obj, "sender", "") or ""
        to = getattr(msg_obj, "to", "") or self.get_safe_recipients(getattr(msg_obj, "recipients", None))
        date = getattr(msg_obj, "date", "") or ""

        self.info_label = QLabel(
            f"<b>–û—Ç:</b> {sender}<br><b>–ö–æ–º—É:</b> {to}<br><b>–¢–µ–º–∞:</b> {subject}<br><b>–î–∞—Ç–∞:</b> {date}"
        )
        self.info_label.setMaximumHeight(84)
        self.info_label.setWordWrap(True)
        layout.addWidget(self.info_label)

        switch_layout = QHBoxLayout()
        self.radio_text = QRadioButton("–¢–µ–∫—Å—Ç")
        self.radio_html = QRadioButton("HTML")
        self.radio_text.setChecked(True)
        switch_layout.addWidget(self.radio_text)
        switch_layout.addWidget(self.radio_html)

        self.btn_convert = QPushButton("–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤ EML")
        self.btn_convert.setObjectName("primaryButton")
        self.btn_convert.setToolTip("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —ç—Ç–æ –ø–∏—Å—å–º–æ –∫–∞–∫ .eml")
        switch_layout.addStretch()
        switch_layout.addWidget(self.btn_convert)
        layout.addLayout(switch_layout)

        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setMaximumHeight(360)
        layout.addWidget(self.text_edit)

        layout.addWidget(QLabel("–í–ª–æ–∂–µ–Ω–∏—è:"))
        self.attach_list = QListWidget()
        self.attach_list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.attach_list.setMaximumHeight(150)
        layout.addWidget(self.attach_list)

        btn_layout = QHBoxLayout()
        self.btn_save_one = QPushButton("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –≤–ª–æ–∂–µ–Ω–∏–µ")
        self.btn_save_all = QPushButton("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ –≤–ª–æ–∂–µ–Ω–∏—è")
        btn_layout.addWidget(self.btn_save_one)
        btn_layout.addWidget(self.btn_save_all)
        layout.addLayout(btn_layout)

        self.body_text = getattr(msg_obj, "body", "") or ""
        self.body_html = getattr(msg_obj, "htmlBody", "") or b""

        self.attachments = []
        for att in msg_obj.attachments:
            name = att.longFilename or att.shortFilename or "attachment.bin"
            data = att.data
            self.attachments.append((name, data))
            self.attach_list.addItem(name)

        if self.body_html:
            if isinstance(self.body_html, bytes):
                html_str = self.body_html.decode("utf-8", errors="replace")
            else:
                html_str = str(self.body_html)
            self.body_html = inline_cid_images(html_str, msg_obj.attachments)

        self.update_body()

        self.radio_text.toggled.connect(self.update_body)
        self.btn_save_one.clicked.connect(self.save_selected_attachment)
        self.btn_save_all.clicked.connect(lambda: save_attachments_bulk(self.attachments, self))
        self.btn_convert.clicked.connect(self.convert_current_msg)

    def get_safe_recipients(self, recipients):
        if not recipients:
            return ""
        return ", ".join([getattr(r, "email", None) or getattr(r, "display_name", "Unknown") for r in recipients])

    def update_body(self):
        if self.radio_text.isChecked():
            if isinstance(self.body_text, bytes):
                text_str = self.body_text.decode("utf-8", errors="replace")
            else:
                text_str = str(self.body_text)
            self.text_edit.setPlainText(text_str[:10000])
        else:
            self.text_edit.setHtml(self.body_html if self.body_html else "<i>(–ù–µ—Ç HTML-–≤–µ—Ä—Å–∏–∏)</i>")

    def save_selected_attachment(self):
        item = self.attach_list.currentItem()
        if item:
            idx = self.attach_list.row(item)
            name, data = self.attachments[idx]
            save_attachment(data, name, self)

    def convert_current_msg(self):
        try:
            self.converter.convert_msg_to_eml(self.msg_path)
            base = os.path.basename(self.msg_path)
            QMessageBox.information(self, "–ì–æ—Ç–æ–≤–æ", f"–ü–∏—Å—å–º–æ '{base}' —Å–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ –≤ EML –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤:\n{self.converter.output_dir}")
        except Exception as e:
            QMessageBox.critical(self, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å:\n{str(e)}")


class MboxPreviewDialog(QDialog):
    def __init__(self, mbox_path, converter, parent=None):
        super().__init__(parent)
        self.setWindowTitle(f"–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä MBOX: {os.path.basename(mbox_path)}")
        self.setFixedSize(1200, 720)
        self.converter = converter
        self.mbox_path = mbox_path

        layout = QHBoxLayout(self)
        self.list_widget = QListWidget()
        layout.addWidget(self.list_widget, 3)

        right_layout = QVBoxLayout()
        self.info_label = QLabel("–í—ã–±–µ—Ä–∏—Ç–µ –ø–∏—Å—å–º–æ –∏–∑ —Å–ø–∏—Å–∫–∞")
        self.info_label.setMaximumHeight(84)
        self.info_label.setWordWrap(True)
        right_layout.addWidget(self.info_label)

        switch_layout = QHBoxLayout()
        self.radio_text = QRadioButton("–¢–µ–∫—Å—Ç")
        self.radio_html = QRadioButton("HTML")
        self.radio_text.setChecked(True)
        switch_layout.addWidget(self.radio_text)
        switch_layout.addWidget(self.radio_html)

        self.btn_convert_one = QPushButton("–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–µ –ø–∏—Å—å–º–æ")
        self.btn_convert_one.setObjectName("primaryButton")
        self.btn_convert_one.setToolTip("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –ø–∏—Å—å–º–æ –∫–∞–∫ .eml")

        self.btn_convert_all = QPushButton("–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –≤—Å–µ –ø–∏—Å—å–º–∞ MBOX")
        self.btn_convert_all.setObjectName("primaryButton")
        self.btn_convert_all.setToolTip("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤–µ—Å—å MBOX –≤ –≤–∏–¥–µ –Ω–∞–±–æ—Ä–∞ .eml")

        switch_layout.addStretch()
        switch_layout.addWidget(self.btn_convert_one)
        switch_layout.addWidget(self.btn_convert_all)
        right_layout.addLayout(switch_layout)

        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        self.text_edit.setMinimumHeight(360)
        self.text_edit.setMaximumHeight(400)
        right_layout.addWidget(self.text_edit)

        right_layout.addWidget(QLabel("–í–ª–æ–∂–µ–Ω–∏—è:"))
        self.attach_list = QListWidget()
        self.attach_list.setSelectionMode(QAbstractItemView.SingleSelection)
        self.attach_list.setMaximumHeight(120)
        right_layout.addWidget(self.attach_list)

        btn_layout = QHBoxLayout()
        self.btn_save_one = QPushButton("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–µ")
        self.btn_save_all = QPushButton("–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å–µ")
        btn_layout.addWidget(self.btn_save_one)
        btn_layout.addWidget(self.btn_save_all)
        right_layout.addLayout(btn_layout)

        layout.addLayout(right_layout, 7)

        try:
            self.messages = safe_mbox_loader(mbox_path)
            if not self.messages:
                QMessageBox.warning(parent, "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ", "MBOX —Ñ–∞–π–ª –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–∏—Å–µ–º –∏–ª–∏ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω")
                return
            for i, msg in enumerate(self.messages, start=1):
                try:
                    subject = decode_header_safe(msg.get("Subject", "")) or "(–±–µ–∑ —Ç–µ–º—ã)"
                    sender = decode_header_safe(msg.get("From", "")) or "(–±–µ–∑ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è)"
                    if len(subject) > 50:
                        subject = subject[:47] + "..."
                    if len(sender) > 30:
                        sender = sender[:27] + "..."
                    item = QListWidgetItem(f"{i}. {subject} ‚Äî {sender}")
                    item.setData(Qt.UserRole, i - 1)
                    self.list_widget.addItem(item)
                except Exception:
                    item = QListWidgetItem(f"{i}. (–æ—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –ø–∏—Å—å–º–∞)")
                    item.setData(Qt.UserRole, i - 1)
                    self.list_widget.addItem(item)
        except Exception as e:
            QMessageBox.warning(parent, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å MBOX —Ñ–∞–π–ª:\n{str(e)}")
            self.messages = []

        self.list_widget.itemClicked.connect(self.show_message)
        self.radio_text.toggled.connect(self.update_body)
        self.btn_save_one.clicked.connect(self.save_selected_attachment)
        self.btn_save_all.clicked.connect(self.save_all_attachments)
        self.btn_convert_one.clicked.connect(self.convert_selected_message)
        self.btn_convert_all.clicked.connect(self.convert_all_messages_from_dialog)

        self.current_body_text = ""
        self.current_body_html = ""
        self.attachments = []

    def decode_header_safe(self, header_value):
        return decode_header_safe(header_value)

    def decode_payload_safe(self, part):
        """–ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ –ø–∏—Å—å–º–∞"""
        try:
            payload = part.get_payload(decode=True)
            if isinstance(payload, bytes):
                charset = part.get_content_charset()
                if charset:
                    try:
                        return payload.decode(charset)
                    except (UnicodeDecodeError, LookupError):
                        pass
                for encoding in ['utf-8', 'cp1251', 'koi8-r', 'iso-8859-1', 'cp866']:
                    try:
                        return payload.decode(encoding)
                    except UnicodeDecodeError:
                        continue
                return payload.decode('utf-8', errors='replace')
            else:
                return str(payload)
        except:
            try:
                payload = part.get_payload()
                return str(payload)
            except:
                return "(–Ω–µ —É–¥–∞–ª–æ—Å—å –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞—Ç—å —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ)"

    def show_message(self, item):
        index = item.data(Qt.UserRole)
        if index >= len(self.messages):
            self.info_label.setText("–û—à–∏–±–∫–∞: –ø–∏—Å—å–º–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            return
            
        msg = self.messages[index]
        try:
            subject = self.decode_header_safe(msg.get("Subject", ""))
            sender = self.decode_header_safe(msg.get("From", ""))
            to = self.decode_header_safe(msg.get("To", ""))
            date = self.decode_header_safe(msg.get("Date", ""))
        except Exception:
            subject = sender = to = date = "(–æ—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è)"
            
        self.info_label.setText(
            f"<b>–û—Ç:</b> {sender}<br>"
            f"<b>–ö–æ–º—É:</b> {to}<br>"
            f"<b>–¢–µ–º–∞:</b> {subject}<br>"
            f"<b>–î–∞—Ç–∞:</b> {date}"
        )

        text, html = "", ""
        attachments = []
        
        try:
            if msg.is_multipart():
                for part in msg.walk():
                    try:
                        ctype = part.get_content_type()
                        disp = str(part.get("Content-Disposition", "")).lower()
                        
                        if ctype == "text/plain" and "attachment" not in disp:
                            text = self.decode_payload_safe(part)
                        elif ctype == "text/html" and "attachment" not in disp:
                            html = self.decode_payload_safe(part)
                        elif "attachment" in disp or part.get_filename():
                            fname = part.get_filename() or "attachment.bin"
                            fname = self.decode_header_safe(fname)
                            try:
                                data = part.get_payload(decode=True)
                                if data:
                                    attachments.append((fname, data))
                            except:
                                pass
                    except Exception:
                        continue
            else:
                text = self.decode_payload_safe(msg)
        except Exception as e:
            text = f"(–û—à–∏–±–∫–∞ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ: {str(e)})"

        self.current_body_text = text
        self.current_body_html = html
        self.attachments = attachments
        
        self.attach_list.clear()
        for fname, _ in attachments:
            self.attach_list.addItem(fname)
            
        self.update_body()

    def update_body(self):
        if self.radio_text.isChecked():
            self.text_edit.setPlainText(self.current_body_text[:10000])
        else:
            self.text_edit.setHtml(self.current_body_html if self.current_body_html else "<i>(–ù–µ—Ç HTML-–≤–µ—Ä—Å–∏–∏)</i>")

    def save_selected_attachment(self):
        item = self.attach_list.currentItem()
        if item:
            idx = self.attach_list.row(item)
            name, data = self.attachments[idx]
            save_attachment(data, name, self)

    def save_all_attachments(self):
        if self.attachments:
            save_attachments_bulk(self.attachments, self)
        else:
            QMessageBox.information(self, "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è", "–ù–µ—Ç –≤–ª–æ–∂–µ–Ω–∏–π –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è")

    def convert_selected_message(self):
        item = self.list_widget.currentItem()
        if not item:
            QMessageBox.warning(self, "–ù–µ—Ç –≤—ã–±–æ—Ä–∞", "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∏—Å—å–º–æ —Å–ª–µ–≤–∞ –≤ —Å–ø–∏—Å–∫–µ.")
            return
        
        idx = item.data(Qt.UserRole)
        if idx is None or idx >= len(self.messages):
            QMessageBox.warning(self, "–û—à–∏–±–∫–∞", "–ù–µ–≤–µ—Ä–Ω—ã–π –∏–Ω–¥–µ–∫—Å –ø–∏—Å—å–º–∞.")
            return
            
        try:
            msg = self.messages[idx]
            subject = decode_header_safe(msg.get("Subject", "")) or f"message_{idx+1:03d}"
            clean_subject = sanitize_filename(subject)
            
            eml_name = f"{clean_subject}.eml"
            eml_path = os.path.join(self.converter.output_dir, eml_name)
            
            counter = 1
            while os.path.exists(eml_path):
                eml_name = f"{clean_subject}_{counter}.eml"
                eml_path = os.path.join(self.converter.output_dir, eml_name)
                counter += 1
            
            Path(self.converter.output_dir).mkdir(parents=True, exist_ok=True)
            
            with open(eml_path, 'wb') as f:
                generator = email.generator.BytesGenerator(f, policy=email.policy.SMTP)
                generator.flatten(msg)
                
            QMessageBox.information(self, "–ì–æ—Ç–æ–≤–æ", 
                                  f"–ü–∏—Å—å–º–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –∫–∞–∫:\n{eml_path}")
        except Exception as e:
            QMessageBox.critical(self, "–û—à–∏–±–∫–∞", 
                             f"–ù–µ —É–¥–∞–ª–æ—Å—å –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–∏—Å—å–º–æ:\n{str(e)}")

    def convert_all_messages_from_dialog(self):
        try:
            Path(self.converter.output_dir).mkdir(parents=True, exist_ok=True)
            converted = 0
            
            for i, msg in enumerate(self.messages):
                try:
                    subject = decode_header_safe(msg.get("Subject", "")) or f"message_{i+1:03d}"
                    clean_subject = sanitize_filename(subject)
                    
                    eml_name = f"{clean_subject}.eml"
                    eml_path = os.path.join(self.converter.output_dir, eml_name)
                    
                    counter = 1
                    while os.path.exists(eml_path):
                        eml_name = f"{clean_subject}_{counter}.eml"
                        eml_path = os.path.join(self.converter.output_dir, eml_name)
                        counter += 1
                    
                    with open(eml_path, 'wb') as f:
                        generator = email.generator.BytesGenerator(f, policy=email.policy.SMTP)
                        generator.flatten(msg)
                    converted += 1
                    
                except Exception as e:
                    logger.error(f"–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –ø–∏—Å—å–º–∞ {i+1}: {str(e)}")
                    continue
            
            QMessageBox.information(self, "–ì–æ—Ç–æ–≤–æ", 
                f"–°–∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ –ø–∏—Å–µ–º: {converted}\n–ü–∞–ø–∫–∞: {self.converter.output_dir}")
                
        except Exception as e:
            QMessageBox.critical(self, "–û—à–∏–±–∫–∞", 
                f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –ø–∏—Å–µ–º:\n{str(e)}")



class MsgToEmlConverter(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("MSG and MBOX ‚Üí EML –ö–æ–Ω–≤–µ—Ä—Ç–µ—Ä")
        self.resize(650, 500)

        self.config = load_config()
        self.output_dir = self.config["output_dir"]
        
        self.converter = MessageConverter(self.output_dir)

        self.conversion_worker = None
        
        self.init_ui()

        if self.config.get("light_theme", True):
            self.set_light_theme()
            self.theme_checkbox.setChecked(False)
        else:
            self.set_dark_theme()
            self.theme_checkbox.setChecked(True)


    def preview_selected_file(self):
        current_item = self.list_widget.currentItem()
        if current_item:
            self.preview_file(current_item)
        else:
            QMessageBox.warning(self, "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ", "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞")

    def preview_file(self, item):
        file_path = item.text()
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "–û—à–∏–±–∫–∞", "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return

        try:
            if file_path.lower().endswith('.msg'):
                msg = extract_msg.Message(file_path)
                dialog = PreviewDialog("–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä MSG", msg, file_path, self.converter, self)
                dialog.exec_()
            elif file_path.lower().endswith('.mbox'):
                dialog = MboxPreviewDialog(file_path, self.converter, self)
                dialog.exec_()
        except Exception as e:
            QMessageBox.critical(self, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª:\n{str(e)}")

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        top_bar = QHBoxLayout()
        self.label = QLabel("–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ —Ñ–∞–π–ª—ã .msg –∏–ª–∏ .mbox, –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –≤—Ä—É—á–Ω—É—é:")
        top_bar.addWidget(self.label)

        self.preview_button = QPushButton("üìã –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä")
        self.preview_button.setToolTip("–û—Ç–∫—Ä—ã—Ç—å –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –¥–ª—è –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞")
        self.preview_button.clicked.connect(self.preview_selected_file)
        top_bar.addWidget(self.preview_button)

        self.settings_button = QToolButton()
        self.settings_button.setIcon(QIcon.fromTheme("preferences-system"))
        self.settings_button.setPopupMode(QToolButton.InstantPopup)
        self.setup_settings_menu()
        top_bar.addStretch()
        top_bar.addWidget(self.settings_button)
        layout.addLayout(top_bar)

        self.list_widget = DragDropListWidget()
        self.list_widget.itemDoubleClicked.connect(self.preview_file)
        layout.addWidget(self.list_widget)

        btn_layout = QHBoxLayout()
        self.clear_button = QPushButton("üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å —Å–ø–∏—Å–æ–∫")
        self.clear_button.clicked.connect(self.list_widget.clear)
        btn_layout.addStretch()
        btn_layout.addWidget(self.clear_button)
        layout.addLayout(btn_layout)

        self.select_button = QPushButton("–í—ã–±—Ä–∞—Ç—å MSG-—Ñ–∞–π–ª—ã")
        self.select_button.clicked.connect(self.select_files)
        layout.addWidget(self.select_button)

        self.mbox_button = QPushButton("–í—ã–±—Ä–∞—Ç—å MBOX-—Ñ–∞–π–ª—ã")
        self.mbox_button.clicked.connect(self.select_mbox_files)
        layout.addWidget(self.mbox_button)

        self.convert_button = QPushButton("–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å")
        self.convert_button.setObjectName("primaryButton")
        self.convert_button.clicked.connect(self.convert_all)
        layout.addWidget(self.convert_button)

        self.output_info = QLabel(f"–§–∞–π–ª—ã –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤: {self.output_dir}")
        layout.addWidget(self.output_info)

        self.progress = QProgressBar()
        self.progress.setAlignment(Qt.AlignCenter)
        self.progress.setFormat("%p%")
        layout.addWidget(self.progress)

        mk_label = QLabel("MK")
        mk_label.setAlignment(Qt.AlignRight | Qt.AlignBottom)
        mk_label.setStyleSheet("color: gray; padding: 1px;")
        layout.addWidget(mk_label)        

    def preview_selected_file(self):
        """–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞"""
        current_item = self.list_widget.currentItem()
        if current_item:
            self.preview_file(current_item)
        else:
            QMessageBox.warning(self, "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ", "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –¥–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞")

    def preview_file(self, item):
        file_path = item.text()
        if not os.path.exists(file_path):
            QMessageBox.warning(self, "–û—à–∏–±–∫–∞", "–§–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return

        try:
            if file_path.lower().endswith('.msg'):
                msg = extract_msg.Message(file_path)
                dialog = PreviewDialog("–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä MSG", msg, file_path, self.converter, self)
                dialog.exec_()
            elif file_path.lower().endswith('.mbox'):
                dialog = MboxPreviewDialog(file_path, self.converter, self)
                dialog.exec_()
        except Exception as e:
            QMessageBox.critical(self, "–û—à–∏–±–∫–∞", f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å —Ñ–∞–π–ª:\n{str(e)}")

    def setup_settings_menu(self):
        menu = QMenu(self)
        
        self.theme_checkbox = QAction("–¢—ë–º–Ω–∞—è —Ç–µ–º–∞", menu)
        self.theme_checkbox.setCheckable(True)
        self.theme_checkbox.toggled.connect(self.toggle_theme)
        menu.addAction(self.theme_checkbox)
        
        change_output = QAction("–ò–∑–º–µ–Ω–∏—Ç—å –ø–∞–ø–∫—É —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è", menu)
        change_output.triggered.connect(self.select_output_dir)
        menu.addAction(change_output)
        
        self.settings_button.setMenu(menu)

    def toggle_theme(self, checked):
        if checked:
            self.set_dark_theme()
        else:
            self.set_light_theme()
        self.config["dark_theme"] = checked
        save_config(self.config)

    def set_dark_theme(self):
        app = QApplication.instance()
        app.setStyleSheet("""
            QWidget {
                background-color: #2b2b2b;
                color: #ffffff;
            }
            QPushButton {
                background-color: #3b3b3b;
                border: 1px solid #555555;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #454545;
            }
            QPushButton#primaryButton {
                background-color: #0d47a1;
            }
            QPushButton#primaryButton:hover {
                background-color: #1565c0;
            }
            QListWidget {
                border: 1px solid #555555;
            }
            QProgressBar {
                border: 1px solid #555555;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #0d47a1;
            }
        """)

    def set_light_theme(self):
        app = QApplication.instance()
        app.setStyleSheet("""
            QWidget {
                background-color: #f0f0f0;
                color: #000000;
            }
            QPushButton {
                background-color: #ffffff;
                border: 1px solid #cccccc;
                padding: 5px;
                border-radius: 3px;
            }
            QPushButton:hover {
                background-color: #e6e6e6;
            }
            QPushButton#primaryButton {
                background-color: #1976d2;
                color: white;
            }
            QPushButton#primaryButton:hover {
                background-color: #1565c0;
            }
            QListWidget {
                border: 1px solid #cccccc;
            }
            QProgressBar {
                border: 1px solid #cccccc;
                text-align: center;
            }
            QProgressBar::chunk {
                background-color: #1976d2;
            }
        """)

    def select_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self, "–í—ã–±–µ—Ä–∏—Ç–µ MSG —Ñ–∞–π–ª—ã", 
            os.path.expanduser("~"),  # –ù–∞—á–∏–Ω–∞—Ç—å —Å –¥–æ–º–∞—à–Ω–µ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            "MSG —Ñ–∞–π–ª—ã (*.msg);;–í—Å–µ —Ñ–∞–π–ª—ã (*.*)"
        )
        if files:
            self.list_widget.addItems(files)

    def select_mbox_files(self):
        files, _ = QFileDialog.getOpenFileNames(
            self, "–í—ã–±–µ—Ä–∏—Ç–µ MBOX —Ñ–∞–π–ª—ã", 
            os.path.expanduser("~"),  # –ù–∞—á–∏–Ω–∞—Ç—å —Å –¥–æ–º–∞—à–Ω–µ–≥–æ –∫–∞—Ç–∞–ª–æ–≥–∞
            "MBOX —Ñ–∞–π–ª—ã (*.mbox *.mbx);;–í—Å–µ —Ñ–∞–π–ª—ã (*.*)"
        )
        if files:
            self.list_widget.addItems(files)

    def select_output_dir(self):
        dir_path = QFileDialog.getExistingDirectory(
            self, "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞–ø–∫—É –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è",
            self.output_dir
        )
        if dir_path:
            self.output_dir = dir_path
            self.output_info.setText(f"–§–∞–π–ª—ã –±—É–¥—É—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤: {self.output_dir}")
            self.config["output_dir"] = dir_path
            save_config(self.config)

    def convert_all(self):
        files = [self.list_widget.item(i).text() for i in range(self.list_widget.count())]
        if not files:
            QMessageBox.warning(self, "–ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ", "–î–æ–±–∞–≤—å—Ç–µ —Ñ–∞–π–ª—ã –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏")
            return

        os.makedirs(self.output_dir, exist_ok=True)
        
        self.conversion_worker = ConversionWorker(files, self.output_dir, self.converter)
        self.conversion_worker.progress.connect(self.progress.setValue)
        self.conversion_worker.error.connect(self.show_error)
        self.conversion_worker.finished.connect(self.conversion_finished)
        
        self.convert_button.setEnabled(False)
        self.progress.setValue(0)
        self.conversion_worker.start()

    def show_error(self, file_path, error_msg):
        QMessageBox.warning(
            self, "–û—à–∏–±–∫–∞ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏",
            f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ {file_path}:\n{error_msg}"
        )

    def conversion_finished(self):
        self.convert_button.setEnabled(True)
        self.progress.setValue(100)
        QMessageBox.information(
            self, "–ì–æ—Ç–æ–≤–æ",
            f"–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞.\n–§–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤:\n{self.output_dir}"
        )

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.setApplicationName("MSG AND MBOX to EML Converter")
    window = MsgToEmlConverter()
    window.show()
    sys.exit(app.exec_())
